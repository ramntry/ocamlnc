Этот документ описывает, как развернуть на своей машине рабочее окружение
проекта, собрать компилятор и воспользоваться тестами, предназначенными
для сборщика мусора.

По описанной ниже схеме сборку проекта регулярно производит билд-сервер
по сценарию bs.sh. Этот скрипт содержит наиболее актуальную информацию
по порядку сборки проекта.


Несколько слов о структуре проекта, зависимостях и версиях

В состав инструментов OCaml входят: компилятор в байт-код ocamlc,
виртуальная машина для исполнения байткода ocamlrun, компилятор в нативный
код ocamlopt и целый набор дополнительных программ. Почти все эти программы
существуют в двух версиях: в байткод-версии и в нативной версии. В нативном
варианте их названия имеют суффикс opt. Так, например, нативный компилятор
в нативный код называется ocamlopt.opt. В компилятор ocamlc никаких
изменений в рамках проекта не вносится, модифицируется только ocamlopt.

Инструменты OCaml (в том числе ocamlopt) написаны преимущественно на самом
OCaml. На текущем этапе практически весь новый код также написан на OCaml и
сосредоточен в файле asmcomp/llvmgen.ml. Для вызова из кода на OCaml
функций LLVM используются существующие в рамках проекта LLVM биндинги.
Используемая версия LLVM - 3.3, OCaml - 4.01. Платформа - Linux x86-64.

Генерируемый модифицированным компилятором код зависит от библиотеки поддержки
времени выполнения. При сборке каждого теста проихсодит копирование файла,
содержащего код этот библиотеки на языке C (scripts/runtime.c) в папку теста.

На текущем этапе поддерживается сборка только программ, состоящих из одной
единицы компиляции (одного *.ml-файла, который может определять несколько
модулей, в том числе вложенных). Бинарных зависимостей, кроме объектного
файла runtime.o и стандартной библиотеки C, у линкуемого исполняемого модуля
нет.

Сборка библиотеки поддержки runtime.c зависит от доступности заголовочного
файла unwind.h, который может быть установлен в систему вместе с библиотекой
libunwind (см. пакеты с именами типа libunwind8-dev). Это необходимо ввиду
реализации механизма исключений в стиле Intel Itanium C++ ABI.

Среди зависимостей есть autotools, perl, valgrind, curses (искать в пакете
ncurses в варианте dev/devel), gcc/g++.

Сборка проверялась на трёх машинах:

  1. Ubuntu 12.04 LTS
  2. Fedora 19
  3. openSUSE 12.1


Сборка

Первое, что нужно сделать - собрать LLVM 3.3 с поддержкой биндингов к OCaml
версии 4.01. Для этого сначала надо собрать оригинальный OCaml 4.01, так
как компилятор OCaml необходим для сборки этих биндингов. OCaml 4.01 можно
найти в репозитории в ветке 4.01.0-original. Следует, таким образом,
действовать так:


1. Склонировать репозиторий в какой-нибудь каталог и перейти в папку
проекта:

  $ git clone https://github.com/ramntry/ocamlnc.git
  $ cd ocamlnc/

2. Ветка по умолчанию 4.01.0-original (если иначе, то нужно перейти в ветку
4.01.0-original). Сборка этой ветки нужна только для того, чтобы собрать
биндинги, потому можно все параметры сборки оставить по-умолчанию, кроме
-prefix, который лучше установить равным какой-нибудь локальной директории
в домашней папке пользователя. Собрать ветку можно так:

  $ mkdir ../4.01.0-original_build
  $ ./configure -prefix $PWD/../4.01.0-original_build
  $ make world
  $ make opt
  $ make install

Если вы заглянете в INSTALL, то поймёте, что в этой схеме пропущена цель
bootstrap (это пересборка компилятора ocamlc только что собранным ocamlc) и
цель opt.opt (практически полная пересборка проекта компилятором ocamlopt).
Это сделано для экономии времени, потому что bootstrap служит исключительно
для самотестирования, а opt.opt собирается долго. Вклад сборки биндингов во
время сборки LLVM невелик, потому использование для этого ocamlopt.opt
времени сэкономит немного. Сборка более, чем в один поток (с опцией -j n,
где n - число потоков), может завершиться ошибкой.

3. Теперь можно собирать LLVM. Быстрее всего развернуть кодовую базу можно
загрузив архивы с официального сайта (из-под систем контроля версий код
вытягивать дольше). Все архивы можно найти здесь:
http://llvm.org/releases/download.html#3.3. Распаковывать их нужно,
соблюдая оригинальное дерево каталогов, пронаблюдать которое можно тут:
http://llvm.org/releases/3.3/docs/GettingStarted.html. Должно выйти
примерно так:

  $ cd ../
  $ mkdir llvm-3.3
  $ cd llvm-3.3

  $ wget http://llvm.org/releases/3.3/llvm-3.3.src.tar.gz
  $ tar -xzf llvm-3.3.src.tar.gz
  $ mv llvm-3.3.src llvm

  $ wget http://llvm.org/releases/3.3/cfe-3.3.src.tar.gz
  $ tar -xzf cfe-3.3.src.tar.gz
  $ mv cfe-3.3.src llvm/tools/clang

  $ wget http://llvm.org/releases/3.3/compiler-rt-3.3.src.tar.gz
  $ tar -xzf compiler-rt-3.3.src.tar.gz
  $ mv compiler-rt-3.3.src llvm/projects/compiler-rt

Сборка Clang необязательна, но совсем не помешает.

4. Конфигурировать сборку LLVM я предлагаю так:

  $ mkdir build dist
  $ cd build/
  $ export PATH=$PWD/../../4.01.0-original_build/bin:$PATH
  $ ../llvm/configure --enable-debug-runtime --enable-keep-symbols \
    --enable-bindings=ocaml --enable-targets=x86_64 --prefix=$PWD/../dist

Переменная окружения PATH устанавливается так, чтобы скрипт configure
смог найти исполняемые файлы OCaml.

5. Собствено сборка и инсталляция традиционны:

  $ make
  $ make install

Для сборки более, чем в один поток необходим большой объём оперативной
памяти. 1 Gb может оказаться мало. Однако в случае сбоя сборка LLVM обычно
успешно продолжается повторной командой make без опции -j.
Среди зависимостей для команды make install есть программы pod2man (искать
в пакетах perl, perl-podlators), groff.

Важно, что после инсталляции перемещать директорию с установленным
LLVM нельзя, так как часть библиотек в каталоге с биндингами доступна
только по символическим ссылкам.

6. Теперь возможна сборка проектной версии ocamlopt.opt. Сначала нужно
переключиться в подходящую ветку проекта, например, jblab-gc-master:

  $ cd ../../ocamlnc/
  $ git fetch origin jblab-gc-master 
  $ git checkout -b jblab-gc-master origin/jblab-gc-master

7. Затем скопировать шаблон <ocamlnc>/_setenv.sh в файл с именем setenv.sh
и отредактировать копию, установив все необходимые пути:

  $ cp _setenv.sh setenv.sh
  $ vi setenv.sh

Описание переменных:

  OCAML_ROOT - полный путь к директории инсталляции компилятора (не ветки
      4.01.0-original_build, а ветки jblab-gc-master). Должна существовать
      и при первой сборке быть пустой.
  LLVM_ROOT - полный путь к директории инсталляции LLVM.
  LLVM_SRC_ROOT - полный путь к директории с исходным кодом LLVM (той, что
      содержит скрипт configure).
  LLVM_OBJ_ROOT - полный путь к директории сборки копии LLVM,
      инсталлированной в $LLVM_ROOT. Может совпадать с $LLVM_SRC_ROOT, но
      обычно это отдельный build-каталог.

  JBLABGC - полный путь к динамической библиотеке, регистрирующей
      наследника класса llvm::GCStrategy, иначе говоря - к GC-плагину.

Значение по умолчанию переменной $JBLABGC при первой сборке лучше не
менять - оно указывает на GC-заглушку, автоматически собирающуюся на
основе проекта $LLVM_SRC_ROOT/projects/sample. О сборке проектов для LLVM
можно прочесть здесь: http://llvm.org/releases/3.3/docs/Projects.html.
Сборку заглушки осуществляет скрипт build_dummy_gc.sh, потенциально самый
ненадёжный скрипт из системы сборки. Вызывать его вручную, особенно при
первой сборке, скорее всего не возникнет необходимости. Важно, что этот
скрипт в ходе работы удаляет каталог с именем, совпадающим с именем
*.so-файла плагина (только без суффикса .so) в директории
$LLVM_SRC_ROOT/projects, если такой есть.

Перед сборкой или пересборкой проектной версии компилятора, GC-плагина с
заглушкой, перед запуском или компиляцией тестов необходимо быть уверенным,
что переменные окружения, перечисленные в файле setenv.sh, установлены
верно. Для этого обычно достаточно в начале сессии командного
интерпретатора выполнить команду:

  $ . setenv.sh

в каталоге проекта. Важно понимать, что это действие устанавливает пути
в том числе к только что собранному LLVM, что может привести к конфликтам
при сборке других LLVM-проектов.

8. Для сборки, инсталляции проектной версии компилятора, инсталляции
набора скриптов (в основном для быстрого создания новых тестов и их
сборки), сборки и прогона одного из тестов в автоматическом режиме следует
выполнить команду:

  $ ./deploy.sh

Скрипт deploy.sh выполняет следующие действия:

  # запускает configure-скрипт с необходимыми опциями, подготавливает файл
  # зависимостей между файлами проекта
  ./run_configure.sh && cp _depend .depend

  # осуществляет полную сборку компилятора
  make world && make bootstrap
  make depend    # положение команды make depend (пересчёта
  make opt       #   зависимостей) относительно других критично
  make opt.opt

  # устанавливает собранный компилятор и набор скриптов в каталог $OCAML_ROOT
  make install && cp -r scripts $OCAML_ROOT/bin

  # осуществляет попытку сборки GC-заглушки
  ./build_dummy_gc.sh

  # собирает и запускает тесты (один (trees) нагрузочный для теста GC и
  # все из тестового набора ocamlnc)
  make test

9. Вне зависимости от успешности или неуспешности сборки заглушки и
выполнения теста, иной плагин сборщика мусора подключается к тесту в 3
шага:

  1. Указать путь к *.so-файлу в setenv.sh значением переменной $JBLABGC
  2. Выполнить команду . setenv.sh
  3. Пересобрать и перезапустить тест, выполнив скрипт check.sh в каталоге
     теста (<ocamlnc>/gc/tests/trees)

Если полный путь к файлу плагина при его пересборках не меняется, шаг (2)
достаточно выполнить один раз за сессию командного интерпретатора.
